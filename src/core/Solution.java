package core;

/**
 * 正式面试用
 */
public class Solution {
//工厂模式（Factory Pattern）：适用于需要创建多种产品对象的场景，将对象的创建过程放到工厂类中，客户端通过工厂类获取需要的对象。
//开源应用场景：Spring框架中的BeanFactory，可以根据配置文件中的配置信息创建不同的Bean对象。
//
//示例代码：Spring源码中的DefaultListableBeanFactory类
//
//单例模式（Singleton Pattern）：适用于需要保证整个系统中只有一个实例对象的场景，如数据库连接池、日志管理器等。
//开源应用场景：Tomcat服务器中的SessionManager，通过单例模式来管理Session对象。
//
//示例代码：Tomcat源码中的SessionManagerBase类
//
//装饰器模式（Decorator Pattern）：适用于需要动态地给一个对象增加额外的功能，而且可以动态地撤销该功能的场景。
//开源应用场景：Java I O库中的装饰器流，可以动态地给输入输出流添加功能，如缓冲、压缩、加密等。
//
//示例代码：Java SE源码中的BufferedInputStream类
//
//观察者模式（Observer Pattern）：适用于一对多的对象依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都将得到通知并自动更新。
//开源应用场景：Spring框架中的事件机制，可以实现对象间的松耦合，当一个事件发生时，所有监听该事件的对象都将得到通知。
//
//示例代码：Spring源码中的ApplicationEventPublisher类
//
//策略模式（Strategy Pattern）：适用于需要在运行时根据不同的情况选择不同的算法实现的场景，将算法的实现和使用分离开来。
//开源应用场景：Java SE中的Comparator接口，可以根据不同的排序需求使用不同的比较器实现。
//
//示例代码：Java SE源码中的Collections类中的sort方法




}